datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

generator client {
  provider = "prisma-client-js"
}

model User {
  id            String    @id @default(cuid())
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  // Anonymous fields (visible only after mutual match)
  displayName   String?
  photos        Json?
  bio           String?
  age           Int?
  gender        String?
  interests     String[]

  // Always private
  phone         String?   @unique
  email         String?   @unique
  tokenBalance  Int       @default(0)

  // Relations (ignore for now)
  sessionsAsA   Session[] @relation("UserASessions")
  sessionsAsB   Session[] @relation("UserBSessions")
  matchesAsA    Match[]   @relation("UserAMatches")
  matchesAsB    Match[]   @relation("UserBMatches")
  tokenTxs      TokenTransaction[]
  moderation    ModerationEvent[]
  refreshTokens RefreshToken[]
  messagesSent  Message[]
}

model RefreshToken {
  id           String   @id @default(cuid())
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  userId       String
  tokenHash    String   @unique
  familyId     String
  expiresAt    DateTime
  revokedAt    DateTime?
  replacedById String?
  userAgent    String?
  ipAddress    String?
  lastUsedAt   DateTime?
  sessionName  String?

  user User @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId])
  @@index([familyId])
}

model Session {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userAId   String
  userBId   String
  region    String?
  queueKey  String?

  userA User @relation("UserASessions", fields: [userAId], references: [id])
  userB User @relation("UserBSessions", fields: [userBId], references: [id])

  @@index([queueKey])
}

model Match {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  userAId   String
  userBId   String

  userA User @relation("UserAMatches", fields: [userAId], references: [id])
  userB User @relation("UserBMatches", fields: [userBId], references: [id])
  messages Message[]

  @@unique([userAId, userBId])
  @@index([userAId])
  @@index([userBId])
}

model Message {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  matchId   String
  senderId  String
  text      String

  match  Match @relation(fields: [matchId], references: [id], onDelete: Cascade)
  sender User  @relation(fields: [senderId], references: [id], onDelete: Cascade)

  @@index([matchId, createdAt])
  @@index([senderId])
}

model TokenTransaction {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  userId    String
  type      TokenTransactionType
  amount    Int
  balanceAfter Int
  stripeSessionId String? @unique
  stripeEventId   String? @unique
  metadata  Json?

  user User @relation(fields: [userId], references: [id])

  @@index([userId])
}

enum TokenTransactionType {
  CREDIT
  DEBIT
}

model ModerationEvent {
  id        String   @id @default(cuid())
  createdAt DateTime @default(now())
  userId    String

  user User @relation(fields: [userId], references: [id])
}
