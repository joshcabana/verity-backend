import fs from 'node:fs';
import path from 'node:path';
import { fileURLToPath } from 'node:url';

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const webRoot = path.resolve(__dirname, '..');
const legalDocsRoot = path.resolve(webRoot, '..', 'docs', 'legal');
const outputPath = path.resolve(webRoot, 'src', 'legal', 'generated.ts');

const docsConfig = [
  { key: 'privacy', file: 'privacy-policy.md' },
  { key: 'terms', file: 'terms-of-service.md' },
  { key: 'community', file: 'community-guidelines.md' },
  { key: 'cookies', file: 'cookie-notice.md' },
];

function normalizeInline(text) {
  return text
    .replace(/\[([^\]]+)\]\([^)]+\)/g, '$1')
    .replace(/\*\*([^*]+)\*\*/g, '$1')
    .replace(/`([^`]+)`/g, '$1')
    .trim();
}

function parseMarkdown(content, filename) {
  const lines = content.split(/\r?\n/);
  let title = '';
  let updated = '';
  const sections = [];
  let currentSection = null;
  let canAppendToPrevious = false;

  for (const rawLine of lines) {
    const line = rawLine.trim();
    if (!line) {
      canAppendToPrevious = false;
      continue;
    }

    if (!title && line.startsWith('# ')) {
      title = normalizeInline(line.slice(2));
      continue;
    }

    if (!updated && line.startsWith('**Last updated:**')) {
      updated = normalizeInline(line.replace('**Last updated:**', ''));
      continue;
    }

    if (line.startsWith('**Region:**')) {
      continue;
    }

    if (line.startsWith('## ')) {
      currentSection = {
        heading: normalizeInline(line.slice(3)),
        body: [],
      };
      sections.push(currentSection);
      canAppendToPrevious = false;
      continue;
    }

    if (line.startsWith('- ')) {
      if (!currentSection) {
        continue;
      }
      currentSection.body.push(normalizeInline(line.slice(2)));
      canAppendToPrevious = true;
      continue;
    }

    if (line.startsWith('This is a draft')) {
      continue;
    }

    if (currentSection) {
      const normalized = normalizeInline(line);
      if (canAppendToPrevious && currentSection.body.length > 0) {
        const lastIndex = currentSection.body.length - 1;
        currentSection.body[lastIndex] =
          `${currentSection.body[lastIndex]} ${normalized}`.trim();
      } else {
        currentSection.body.push(normalized);
      }
      canAppendToPrevious = true;
    }
  }

  if (!title) {
    throw new Error(`Missing title in ${filename}`);
  }

  if (!updated) {
    updated = 'Unknown';
  }

  return { title, updated, sections };
}

function buildGeneratedSource(docs) {
  const serializedDocs = JSON.stringify(docs, null, 2);
  return `/* eslint-disable */
// This file is auto-generated by scripts/generate-legal-content.mjs.
// Do not edit manually.

export type LegalSection = {
  heading: string;
  body: string[];
};

export type LegalDoc = {
  title: string;
  updated: string;
  sections: LegalSection[];
};

export const legalDocs = ${serializedDocs} as const satisfies Record<string, LegalDoc>;
`;
}

function main() {
  const docs = {};
  for (const { key, file } of docsConfig) {
    const inputPath = path.resolve(legalDocsRoot, file);
    if (!fs.existsSync(inputPath)) {
      throw new Error(`Missing legal source file: ${inputPath}`);
    }
    const content = fs.readFileSync(inputPath, 'utf8');
    docs[key] = parseMarkdown(content, file);
  }

  const source = buildGeneratedSource(docs);
  fs.mkdirSync(path.dirname(outputPath), { recursive: true });
  const current = fs.existsSync(outputPath)
    ? fs.readFileSync(outputPath, 'utf8')
    : null;

  if (current === source) {
    console.log('Legal content already up to date.');
    return;
  }

  fs.writeFileSync(outputPath, source, 'utf8');
  console.log(`Generated ${path.relative(webRoot, outputPath)}`);
}

main();
